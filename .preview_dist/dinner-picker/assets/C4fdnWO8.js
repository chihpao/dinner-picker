import{b as S,u as _}from"./BjSyBa9A.js";import{C as y}from"./B6HfJZvd.js";const x=()=>{const v="dinnerPicker.accounts.v1",p="dinnerPicker.accounts.pending",l="accounts",u=S(),{user:s}=_(),n=y("accounts",()=>[]),m=y("accounts-loading",()=>!1),A=()=>{try{const r=localStorage.getItem(v),t=r?JSON.parse(r):[];return Array.isArray(t)?t.filter(e=>e.user_id===s.value?.id):[]}catch(r){return console.error("Failed to parse local accounts",r),[]}},i=r=>{try{const t=localStorage.getItem(v),e=t?JSON.parse(t):[],a=Array.isArray(e)?e.filter(o=>o.user_id!==s.value?.id):[];localStorage.setItem(v,JSON.stringify([...a,...r]))}catch(t){console.error("Failed to save local accounts",t)}},d=()=>{try{const r=localStorage.getItem(p),t=r?JSON.parse(r):[];return Array.isArray(t)?t.filter(e=>e.user_id===s.value?.id):[]}catch(r){return console.error("Failed to parse pending accounts",r),[]}},f=r=>{try{const t=localStorage.getItem(p),e=t?JSON.parse(t):[],a=Array.isArray(e)?e.filter(o=>o.user_id!==s.value?.id):[];localStorage.setItem(p,JSON.stringify([...a,...r]))}catch(t){console.error("Failed to save pending accounts",t)}},h=async()=>{if(!s.value)return[];m.value=!0;const{data:r,error:t}=await u.from(l).select("*").eq("user_id",s.value.id).order("created_at",{ascending:!1});if(m.value=!1,t)throw t;return(r??[]).map(e=>({id:e.id,name:e.name,kind:e.kind??"bank",balance:e.balance??0,createdAt:e.created_at?new Date(e.created_at).getTime():Date.now(),user_id:e.user_id}))},w=async()=>{if(!s.value)return;const r=d();if(!r.length)return;const t=[];for(const e of r)try{const a={id:e.id,name:e.name,kind:e.kind,balance:e.balance??0,created_at:new Date(e.createdAt).toISOString(),user_id:s.value.id},{error:o}=await u.from(l).insert(a);if(o)throw o}catch(a){console.error("Retry pending accounts failed",a),t.push(e)}f(t)};return{accounts:n,loading:m,loadAccounts:async()=>{if(!s.value){n.value=[];return}try{await w()}catch(r){console.error("sync pending accounts failed",r)}try{const r=await h(),t=d(),e=new Set(r.map(a=>a.id));n.value=[...t.filter(a=>!e.has(a.id)),...r],i(n.value)}catch(r){console.error("Supabase read failed for accounts, using local",r);const t=A(),e=d(),a=new Set(t.map(o=>o.id));n.value=[...e.filter(o=>!a.has(o.id)),...t]}},addAccount:async r=>{if(!s.value)return;const t=d();t.unshift(r),f(t),n.value.unshift(r),i(n.value);try{const e={id:r.id,name:r.name,kind:r.kind,balance:r.balance??0,created_at:new Date(r.createdAt).toISOString(),user_id:s.value.id},{error:a}=await u.from(l).insert(e);if(a)throw a;const o=d().filter(g=>g.id!==r.id);f(o)}catch(e){console.warn("Cloud sync failed for accounts, kept in pending",e)}},updateAccount:async r=>{if(!s.value)return;const t=n.value.find(c=>c.id===r.id);if(!t)return;const e={...t,...r,user_id:s.value.id},a=[...n.value];n.value=n.value.map(c=>c.id===e.id?e:c),i(n.value);const o=d(),g=o.findIndex(c=>c.id===e.id);if(g!==-1){o[g]=e,f(o);return}try{const{error:c}=await u.from(l).update({name:e.name,kind:e.kind,balance:e.balance??0}).eq("id",e.id).eq("user_id",s.value.id);if(c)throw c}catch(c){n.value=a,i(a),alert(`更新帳戶失敗：${c.message}`)}},deleteAccount:async r=>{if(!s.value)return;const t=[...n.value];n.value=n.value.filter(e=>e.id!==r),i(n.value);try{const{error:e}=await u.from(l).delete().eq("id",r).eq("user_id",s.value.id);if(e)throw e}catch(e){n.value=t,i(t),alert(`刪除帳戶失敗：${e.message}`)}}}};export{x as u};
